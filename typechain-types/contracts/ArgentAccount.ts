/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  EventFragment,
  FunctionFragment,
  Result,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  OnEvent,
  PromiseOrValue,
  TypedEvent,
  TypedEventFilter,
  TypedListener,
} from "../common";

export type TransactionStruct = {
  txType: PromiseOrValue<BigNumberish>;
  from: PromiseOrValue<BigNumberish>;
  to: PromiseOrValue<BigNumberish>;
  ergsLimit: PromiseOrValue<BigNumberish>;
  ergsPerPubdataByteLimit: PromiseOrValue<BigNumberish>;
  maxFeePerErg: PromiseOrValue<BigNumberish>;
  maxPriorityFeePerErg: PromiseOrValue<BigNumberish>;
  paymaster: PromiseOrValue<BigNumberish>;
  reserved: PromiseOrValue<BigNumberish>[];
  data: PromiseOrValue<BytesLike>;
  signature: PromiseOrValue<BytesLike>;
  factoryDeps: PromiseOrValue<BytesLike>[];
  paymasterInput: PromiseOrValue<BytesLike>;
  reservedDynamic: PromiseOrValue<BytesLike>;
};

export type TransactionStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber[],
  string,
  string,
  string[],
  string,
  string
] & {
  txType: BigNumber;
  from: BigNumber;
  to: BigNumber;
  ergsLimit: BigNumber;
  ergsPerPubdataByteLimit: BigNumber;
  maxFeePerErg: BigNumber;
  maxPriorityFeePerErg: BigNumber;
  paymaster: BigNumber;
  reserved: BigNumber[];
  data: string;
  signature: string;
  factoryDeps: string[];
  paymasterInput: string;
  reservedDynamic: string;
};

export declare namespace ArgentAccount {
  export type CallStruct = {
    to: PromiseOrValue<string>;
    value: PromiseOrValue<BigNumberish>;
    data: PromiseOrValue<BytesLike>;
  };

  export type CallStructOutput = [string, BigNumber, string] & {
    to: string;
    value: BigNumber;
    data: string;
  };
}

export interface ArgentAccountInterface extends utils.Interface {
  functions: {
    "GUARDIAN_ESCAPE()": FunctionFragment;
    "NO_ESCAPE()": FunctionFragment;
    "NO_GUARDIAN()": FunctionFragment;
    "OWNER_ESCAPE()": FunctionFragment;
    "VERSION()": FunctionFragment;
    "cancelEscape()": FunctionFragment;
    "changeGuardian(address)": FunctionFragment;
    "changeGuardianBackup(address)": FunctionFragment;
    "changeOwner(address)": FunctionFragment;
    "escape()": FunctionFragment;
    "escapeGuardian(address)": FunctionFragment;
    "escapeOwner(address)": FunctionFragment;
    "escapeSecurityPeriod()": FunctionFragment;
    "executeTransaction(bytes32,bytes32,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256[6],bytes,bytes,bytes32[],bytes,bytes))": FunctionFragment;
    "executeTransactionFromOutside((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256[6],bytes,bytes,bytes32[],bytes,bytes))": FunctionFragment;
    "guardian()": FunctionFragment;
    "guardianBackup()": FunctionFragment;
    "implementation()": FunctionFragment;
    "initialize(address,address)": FunctionFragment;
    "isValidSignature(bytes32,bytes)": FunctionFragment;
    "multicall((address,uint256,bytes)[])": FunctionFragment;
    "owner()": FunctionFragment;
    "payForTransaction(bytes32,bytes32,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256[6],bytes,bytes,bytes32[],bytes,bytes))": FunctionFragment;
    "prePaymaster(bytes32,bytes32,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256[6],bytes,bytes,bytes32[],bytes,bytes))": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "triggerEscapeGuardian()": FunctionFragment;
    "triggerEscapeOwner()": FunctionFragment;
    "upgrade(address)": FunctionFragment;
    "validateTransaction(bytes32,bytes32,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256[6],bytes,bytes,bytes32[],bytes,bytes))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "GUARDIAN_ESCAPE"
      | "NO_ESCAPE"
      | "NO_GUARDIAN"
      | "OWNER_ESCAPE"
      | "VERSION"
      | "cancelEscape"
      | "changeGuardian"
      | "changeGuardianBackup"
      | "changeOwner"
      | "escape"
      | "escapeGuardian"
      | "escapeOwner"
      | "escapeSecurityPeriod"
      | "executeTransaction"
      | "executeTransactionFromOutside"
      | "guardian"
      | "guardianBackup"
      | "implementation"
      | "initialize"
      | "isValidSignature"
      | "multicall"
      | "owner"
      | "payForTransaction"
      | "prePaymaster"
      | "supportsInterface"
      | "triggerEscapeGuardian"
      | "triggerEscapeOwner"
      | "upgrade"
      | "validateTransaction"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "GUARDIAN_ESCAPE",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NO_ESCAPE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "NO_GUARDIAN",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OWNER_ESCAPE",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "VERSION", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "cancelEscape",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "changeGuardian",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeGuardianBackup",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "escape", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "escapeGuardian",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "escapeOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "escapeSecurityPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeTransaction",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      TransactionStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTransactionFromOutside",
    values: [TransactionStruct]
  ): string;
  encodeFunctionData(functionFragment: "guardian", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "guardianBackup",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "implementation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isValidSignature",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [ArgentAccount.CallStruct[]]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "payForTransaction",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      TransactionStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "prePaymaster",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      TransactionStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "triggerEscapeGuardian",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "triggerEscapeOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "upgrade",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "validateTransaction",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      TransactionStruct
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "GUARDIAN_ESCAPE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "NO_ESCAPE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "NO_GUARDIAN",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "OWNER_ESCAPE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "VERSION", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelEscape",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeGuardian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeGuardianBackup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "escape", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "escapeGuardian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "escapeOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "escapeSecurityPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTransactionFromOutside",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "guardian", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "guardianBackup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "implementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isValidSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "payForTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prePaymaster",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "triggerEscapeGuardian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "triggerEscapeOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgrade", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "validateTransaction",
    data: BytesLike
  ): Result;

  events: {
    "AccountCreated(address,address,address)": EventFragment;
    "AccountUpgraded(address)": EventFragment;
    "EscapeCancelled()": EventFragment;
    "EscapeGuardianTriggerred(uint32)": EventFragment;
    "EscapeOwnerTriggerred(uint32)": EventFragment;
    "GuardianBackupChanged(address)": EventFragment;
    "GuardianChanged(address)": EventFragment;
    "GuardianEscaped(address)": EventFragment;
    "OwnerChanged(address)": EventFragment;
    "OwnerEscaped(address)": EventFragment;
    "TransactionExecuted(bytes32,bytes)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AccountCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AccountUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EscapeCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EscapeGuardianTriggerred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EscapeOwnerTriggerred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GuardianBackupChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GuardianChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GuardianEscaped"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerEscaped"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionExecuted"): EventFragment;
}

export interface AccountCreatedEventObject {
  account: string;
  owner: string;
  guardian: string;
}
export type AccountCreatedEvent = TypedEvent<
  [string, string, string],
  AccountCreatedEventObject
>;

export type AccountCreatedEventFilter = TypedEventFilter<AccountCreatedEvent>;

export interface AccountUpgradedEventObject {
  newImplementation: string;
}
export type AccountUpgradedEvent = TypedEvent<
  [string],
  AccountUpgradedEventObject
>;

export type AccountUpgradedEventFilter = TypedEventFilter<AccountUpgradedEvent>;

export interface EscapeCancelledEventObject {}
export type EscapeCancelledEvent = TypedEvent<[], EscapeCancelledEventObject>;

export type EscapeCancelledEventFilter = TypedEventFilter<EscapeCancelledEvent>;

export interface EscapeGuardianTriggerredEventObject {
  activeAt: number;
}
export type EscapeGuardianTriggerredEvent = TypedEvent<
  [number],
  EscapeGuardianTriggerredEventObject
>;

export type EscapeGuardianTriggerredEventFilter =
  TypedEventFilter<EscapeGuardianTriggerredEvent>;

export interface EscapeOwnerTriggerredEventObject {
  activeAt: number;
}
export type EscapeOwnerTriggerredEvent = TypedEvent<
  [number],
  EscapeOwnerTriggerredEventObject
>;

export type EscapeOwnerTriggerredEventFilter =
  TypedEventFilter<EscapeOwnerTriggerredEvent>;

export interface GuardianBackupChangedEventObject {
  newGuardianBackup: string;
}
export type GuardianBackupChangedEvent = TypedEvent<
  [string],
  GuardianBackupChangedEventObject
>;

export type GuardianBackupChangedEventFilter =
  TypedEventFilter<GuardianBackupChangedEvent>;

export interface GuardianChangedEventObject {
  newGuardian: string;
}
export type GuardianChangedEvent = TypedEvent<
  [string],
  GuardianChangedEventObject
>;

export type GuardianChangedEventFilter = TypedEventFilter<GuardianChangedEvent>;

export interface GuardianEscapedEventObject {
  newGuardian: string;
}
export type GuardianEscapedEvent = TypedEvent<
  [string],
  GuardianEscapedEventObject
>;

export type GuardianEscapedEventFilter = TypedEventFilter<GuardianEscapedEvent>;

export interface OwnerChangedEventObject {
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<[string], OwnerChangedEventObject>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerEscapedEventObject {
  newOwner: string;
}
export type OwnerEscapedEvent = TypedEvent<[string], OwnerEscapedEventObject>;

export type OwnerEscapedEventFilter = TypedEventFilter<OwnerEscapedEvent>;

export interface TransactionExecutedEventObject {
  hashed: string;
  response: string;
}
export type TransactionExecutedEvent = TypedEvent<
  [string, string],
  TransactionExecutedEventObject
>;

export type TransactionExecutedEventFilter =
  TypedEventFilter<TransactionExecutedEvent>;

export interface ArgentAccount extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ArgentAccountInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    GUARDIAN_ESCAPE(overrides?: CallOverrides): Promise<[number]>;

    NO_ESCAPE(overrides?: CallOverrides): Promise<[number]>;

    NO_GUARDIAN(overrides?: CallOverrides): Promise<[string]>;

    OWNER_ESCAPE(overrides?: CallOverrides): Promise<[number]>;

    VERSION(overrides?: CallOverrides): Promise<[string]>;

    cancelEscape(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeGuardian(
      _newGuardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeGuardianBackup(
      _newGuardianBackup: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeOwner(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    escape(
      overrides?: CallOverrides
    ): Promise<[number, number] & { activeAt: number; escapeType: number }>;

    escapeGuardian(
      _newGuardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    escapeOwner(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    escapeSecurityPeriod(overrides?: CallOverrides): Promise<[number]>;

    executeTransaction(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeTransactionFromOutside(
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    guardian(overrides?: CallOverrides): Promise<[string]>;

    guardianBackup(overrides?: CallOverrides): Promise<[string]>;

    implementation(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      _owner: PromiseOrValue<string>,
      _guardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isValidSignature(
      _hash: PromiseOrValue<BytesLike>,
      _signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    multicall(
      _calls: ArgentAccount.CallStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    payForTransaction(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    prePaymaster(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    triggerEscapeGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    triggerEscapeOwner(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgrade(
      _newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    validateTransaction(
      arg0: PromiseOrValue<BytesLike>,
      _suggestedSignedHash: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  GUARDIAN_ESCAPE(overrides?: CallOverrides): Promise<number>;

  NO_ESCAPE(overrides?: CallOverrides): Promise<number>;

  NO_GUARDIAN(overrides?: CallOverrides): Promise<string>;

  OWNER_ESCAPE(overrides?: CallOverrides): Promise<number>;

  VERSION(overrides?: CallOverrides): Promise<string>;

  cancelEscape(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeGuardian(
    _newGuardian: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeGuardianBackup(
    _newGuardianBackup: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeOwner(
    _newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  escape(
    overrides?: CallOverrides
  ): Promise<[number, number] & { activeAt: number; escapeType: number }>;

  escapeGuardian(
    _newGuardian: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  escapeOwner(
    _newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  escapeSecurityPeriod(overrides?: CallOverrides): Promise<number>;

  executeTransaction(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BytesLike>,
    _transaction: TransactionStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeTransactionFromOutside(
    _transaction: TransactionStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  guardian(overrides?: CallOverrides): Promise<string>;

  guardianBackup(overrides?: CallOverrides): Promise<string>;

  implementation(overrides?: CallOverrides): Promise<string>;

  initialize(
    _owner: PromiseOrValue<string>,
    _guardian: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isValidSignature(
    _hash: PromiseOrValue<BytesLike>,
    _signature: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  multicall(
    _calls: ArgentAccount.CallStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  payForTransaction(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BytesLike>,
    _transaction: TransactionStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  prePaymaster(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BytesLike>,
    _transaction: TransactionStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supportsInterface(
    _interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  triggerEscapeGuardian(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  triggerEscapeOwner(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgrade(
    _newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  validateTransaction(
    arg0: PromiseOrValue<BytesLike>,
    _suggestedSignedHash: PromiseOrValue<BytesLike>,
    _transaction: TransactionStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    GUARDIAN_ESCAPE(overrides?: CallOverrides): Promise<number>;

    NO_ESCAPE(overrides?: CallOverrides): Promise<number>;

    NO_GUARDIAN(overrides?: CallOverrides): Promise<string>;

    OWNER_ESCAPE(overrides?: CallOverrides): Promise<number>;

    VERSION(overrides?: CallOverrides): Promise<string>;

    cancelEscape(overrides?: CallOverrides): Promise<void>;

    changeGuardian(
      _newGuardian: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeGuardianBackup(
      _newGuardianBackup: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeOwner(
      _newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    escape(
      overrides?: CallOverrides
    ): Promise<[number, number] & { activeAt: number; escapeType: number }>;

    escapeGuardian(
      _newGuardian: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    escapeOwner(
      _newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    escapeSecurityPeriod(overrides?: CallOverrides): Promise<number>;

    executeTransaction(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    executeTransactionFromOutside(
      _transaction: TransactionStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    guardian(overrides?: CallOverrides): Promise<string>;

    guardianBackup(overrides?: CallOverrides): Promise<string>;

    implementation(overrides?: CallOverrides): Promise<string>;

    initialize(
      _owner: PromiseOrValue<string>,
      _guardian: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    isValidSignature(
      _hash: PromiseOrValue<BytesLike>,
      _signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    multicall(
      _calls: ArgentAccount.CallStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    payForTransaction(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    prePaymaster(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    triggerEscapeGuardian(overrides?: CallOverrides): Promise<void>;

    triggerEscapeOwner(overrides?: CallOverrides): Promise<void>;

    upgrade(
      _newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    validateTransaction(
      arg0: PromiseOrValue<BytesLike>,
      _suggestedSignedHash: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AccountCreated(address,address,address)"(
      account?: null,
      owner?: null,
      guardian?: null
    ): AccountCreatedEventFilter;
    AccountCreated(
      account?: null,
      owner?: null,
      guardian?: null
    ): AccountCreatedEventFilter;

    "AccountUpgraded(address)"(
      newImplementation?: null
    ): AccountUpgradedEventFilter;
    AccountUpgraded(newImplementation?: null): AccountUpgradedEventFilter;

    "EscapeCancelled()"(): EscapeCancelledEventFilter;
    EscapeCancelled(): EscapeCancelledEventFilter;

    "EscapeGuardianTriggerred(uint32)"(
      activeAt?: null
    ): EscapeGuardianTriggerredEventFilter;
    EscapeGuardianTriggerred(
      activeAt?: null
    ): EscapeGuardianTriggerredEventFilter;

    "EscapeOwnerTriggerred(uint32)"(
      activeAt?: null
    ): EscapeOwnerTriggerredEventFilter;
    EscapeOwnerTriggerred(activeAt?: null): EscapeOwnerTriggerredEventFilter;

    "GuardianBackupChanged(address)"(
      newGuardianBackup?: null
    ): GuardianBackupChangedEventFilter;
    GuardianBackupChanged(
      newGuardianBackup?: null
    ): GuardianBackupChangedEventFilter;

    "GuardianChanged(address)"(newGuardian?: null): GuardianChangedEventFilter;
    GuardianChanged(newGuardian?: null): GuardianChangedEventFilter;

    "GuardianEscaped(address)"(newGuardian?: null): GuardianEscapedEventFilter;
    GuardianEscaped(newGuardian?: null): GuardianEscapedEventFilter;

    "OwnerChanged(address)"(newOwner?: null): OwnerChangedEventFilter;
    OwnerChanged(newOwner?: null): OwnerChangedEventFilter;

    "OwnerEscaped(address)"(newOwner?: null): OwnerEscapedEventFilter;
    OwnerEscaped(newOwner?: null): OwnerEscapedEventFilter;

    "TransactionExecuted(bytes32,bytes)"(
      hashed?: null,
      response?: null
    ): TransactionExecutedEventFilter;
    TransactionExecuted(
      hashed?: null,
      response?: null
    ): TransactionExecutedEventFilter;
  };

  estimateGas: {
    GUARDIAN_ESCAPE(overrides?: CallOverrides): Promise<BigNumber>;

    NO_ESCAPE(overrides?: CallOverrides): Promise<BigNumber>;

    NO_GUARDIAN(overrides?: CallOverrides): Promise<BigNumber>;

    OWNER_ESCAPE(overrides?: CallOverrides): Promise<BigNumber>;

    VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    cancelEscape(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeGuardian(
      _newGuardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeGuardianBackup(
      _newGuardianBackup: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeOwner(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    escape(overrides?: CallOverrides): Promise<BigNumber>;

    escapeGuardian(
      _newGuardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    escapeOwner(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    escapeSecurityPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    executeTransaction(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeTransactionFromOutside(
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    guardian(overrides?: CallOverrides): Promise<BigNumber>;

    guardianBackup(overrides?: CallOverrides): Promise<BigNumber>;

    implementation(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _owner: PromiseOrValue<string>,
      _guardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isValidSignature(
      _hash: PromiseOrValue<BytesLike>,
      _signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    multicall(
      _calls: ArgentAccount.CallStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    payForTransaction(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    prePaymaster(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    triggerEscapeGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    triggerEscapeOwner(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgrade(
      _newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    validateTransaction(
      arg0: PromiseOrValue<BytesLike>,
      _suggestedSignedHash: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    GUARDIAN_ESCAPE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NO_ESCAPE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NO_GUARDIAN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    OWNER_ESCAPE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cancelEscape(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeGuardian(
      _newGuardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeGuardianBackup(
      _newGuardianBackup: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeOwner(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    escape(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    escapeGuardian(
      _newGuardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    escapeOwner(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    escapeSecurityPeriod(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executeTransaction(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeTransactionFromOutside(
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    guardian(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    guardianBackup(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    implementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _owner: PromiseOrValue<string>,
      _guardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isValidSignature(
      _hash: PromiseOrValue<BytesLike>,
      _signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    multicall(
      _calls: ArgentAccount.CallStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    payForTransaction(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    prePaymaster(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    triggerEscapeGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    triggerEscapeOwner(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgrade(
      _newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    validateTransaction(
      arg0: PromiseOrValue<BytesLike>,
      _suggestedSignedHash: PromiseOrValue<BytesLike>,
      _transaction: TransactionStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
